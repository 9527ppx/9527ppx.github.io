---
title: 实现类似于影之刃透视物体效果 
date: 
updated: 
tags:
    - UE
    - 透视
categories:
    - UE
---

# 实现类似于影之刃透视物体效果  
* 实现步骤
    1. C++透视组件实现
    2. 透视材质实现
    3. 组件添加到角色上

## C++透视组件实现
1. 创建组件类
    ![alt text](image-5.png)
2. 具体代码实现  
    .h文件
    ``` C++
        UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
        class AURA_API ULocalWallOcclusionComponent : public UActorComponent
        {
            GENERATED_BODY()

        public:	
            // Sets default values for this component's properties
            ULocalWallOcclusionComponent();

        protected:
            // Called when the game starts
            virtual void BeginPlay() override;
            virtual void EndPlay(const EEndPlayReason::Type EndPlayReason)  override;
            virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
        private:
            void CheckOcclusion();
            void SetWallTransparency(AStaticMeshActor* Wall, bool bTransparent);
            void CleanupAllWalls();
            bool IsLocallyControlled() const;
            
        public:
            UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Occlusion")
            float CheckInterval = 0.1f;
            
            UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Occlusion")
            FName ParameterName = "IsOpenOccMask";
            
            UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Debug")
            bool bShowDebugInfo = false;

        private:
            float TimeSinceLastCheck = 0.0f;
            TSet<AStaticMeshActor*> TransparentWalls;
            bool bIsLocalPlayer = false;
        };
    ```
    .cpp文件
    ``` C++
        ULocalWallOcclusionComponent::ULocalWallOcclusionComponent()
        {
            PrimaryComponentTick.bCanEverTick = true;
            
            // 只在客户端tick
            SetIsReplicatedByDefault(false);
        }


        // Called when the game starts
        void ULocalWallOcclusionComponent::BeginPlay()
        {
            Super::BeginPlay();

            // 检查是否是本地玩家
            bIsLocalPlayer = IsLocallyControlled();
            
            if (bShowDebugInfo && bIsLocalPlayer)
            {
                UE_LOG(LogTemp, Warning, TEXT("LocalWallOcclusion: 组件已在本地玩家上激活"));
            }
            
        }

        void ULocalWallOcclusionComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
        {
            // 清理所有透明墙体
            CleanupAllWalls();
            
            Super::EndPlay(EndPlayReason);
        }


        void ULocalWallOcclusionComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
        {
            Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

            // 只在本地玩家上执行
            if (!bIsLocalPlayer)
            {
                // 动态检查，以防控制权变化
                bIsLocalPlayer = IsLocallyControlled();
                if (!bIsLocalPlayer)
                {
                    return;
                }
            }
            
            // 执行遮挡检测
            TimeSinceLastCheck += DeltaTime;
            if (TimeSinceLastCheck >= CheckInterval)
            {
                CheckOcclusion();
                TimeSinceLastCheck = 0.0f;
            }
        }

        void ULocalWallOcclusionComponent::CheckOcclusion()
        {
            // 再次确认是本地玩家
            if (!IsLocallyControlled())
            {
                bIsLocalPlayer = false;
                CleanupAllWalls();
                return;
            }
            
            // 获取本地玩家控制器和摄像机
            APawn* OwnerPawn = Cast<APawn>(GetOwner());
            if (!OwnerPawn) return;
            
            APlayerController* PC = Cast<APlayerController>(OwnerPawn->GetController());
            if (!PC || !PC->PlayerCameraManager) return;
            
            FVector CameraLoc = PC->PlayerCameraManager->GetCameraLocation();
            FVector CharacterLoc = OwnerPawn->GetActorLocation();

            // 设置要检测的对象类型
            FCollisionObjectQueryParams ObjectQueryParams;
            ObjectQueryParams.AddObjectTypesToQuery(ECC_WorldStatic);  // 只检测静态物体
            
            // 多重射线检测
            TArray<FHitResult> Hits;
            FCollisionQueryParams Params;
            Params.AddIgnoredActor(OwnerPawn);
            
            GetWorld()->LineTraceMultiByObjectType(
                Hits, 
                CharacterLoc, 
                CameraLoc, 
                ObjectQueryParams, 
                Params
            );
            
            // 收集当前遮挡的墙体
            TSet<AStaticMeshActor*> NewTransparentWalls;
            
            for (const FHitResult& Hit : Hits)
            {
                if (AStaticMeshActor* Wall = Cast<AStaticMeshActor>(Hit.GetActor()))
                {
                    NewTransparentWalls.Add(Wall);
                    
                    // 新遮挡的墙体设为透明
                    if (!TransparentWalls.Contains(Wall))
                    {
                        SetWallTransparency(Wall, true);
                        
                        if (bShowDebugInfo)
                        {
                            UE_LOG(LogTemp, Warning, TEXT("设置墙体透明: %s"), *Wall->GetName());
                        }
                    }
                }
            }
            
            // 恢复不再遮挡的墙体
            for (AStaticMeshActor* Wall : TransparentWalls)
            {
                if (!NewTransparentWalls.Contains(Wall) && IsValid(Wall))
                {
                    SetWallTransparency(Wall, false);
                    
                    if (bShowDebugInfo)
                    {
                        UE_LOG(LogTemp, Warning, TEXT("恢复墙体不透明: %s"), *Wall->GetName());
                    }
                }
            }
            
            TransparentWalls = NewTransparentWalls;
        }

        void ULocalWallOcclusionComponent::SetWallTransparency(AStaticMeshActor* Wall, bool bTransparent)
        {
            if (!Wall) return;
            
            UStaticMeshComponent* MeshComp = Wall->GetStaticMeshComponent();
            if (!MeshComp) return;
            
            // 获取或创建动态材质实例
            UMaterialInstanceDynamic* DynMat = Cast<UMaterialInstanceDynamic>(MeshComp->GetMaterial(0));
            if (!DynMat)
            {
                DynMat = MeshComp->CreateDynamicMaterialInstance(0);
            }
            
            if (DynMat)
            {
                DynMat->SetScalarParameterValue(ParameterName, bTransparent ? 1.0f : 0.0f);
            }
        }

        void ULocalWallOcclusionComponent::CleanupAllWalls()
        {
            // 恢复所有墙体为不透明
            for (AStaticMeshActor* Wall : TransparentWalls)
            {
                if (IsValid(Wall))
                {
                    SetWallTransparency(Wall, false);
                }
            }
            TransparentWalls.Empty();
        }

        bool ULocalWallOcclusionComponent::IsLocallyControlled() const
        {
            // 获取拥有者Pawn
            APawn* OwnerPawn = Cast<APawn>(GetOwner());
            if (!OwnerPawn)
            {
                return false;
            }
            
            // 检查是否是本地控制
            if (OwnerPawn->IsLocallyControlled())
            {
                // 额外检查：确保是本地玩家控制器
                APlayerController* PC = Cast<APlayerController>(OwnerPawn->GetController());
                if (PC && PC->IsLocalController())
                {
                    return true;
                }
            }
            
            return false;
        }
    ```

## 透视材质实现
1. 找到静态网格体材质  
    例如：
    ![alt text](image.png)
2. 进入材质
    ![alt text](image-1.png)
    ![alt text](image-2.png)
3. 实现MF_OccMask
    1. 创建材质函数
    ![alt text](image-3.png)
    2. 具体实现
    ![alt text](image-4.png)
## 组件添加到角色上
1. 打开角色添加组件
    ![alt text](image-6.png)
2. 点击组件配置参数
    ![alt text](image-7.png)
    - Check Interval 检测间隔
    - Parameter Name 材质中的变量名称（照着填就行）
    - Show Debug Info 默认关闭不用勾选